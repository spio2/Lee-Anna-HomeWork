# Инструкция по работе с git

## Команды

* *git --version* - команда, позволяющая проверить текущую версию программы;

* *git init* - команда, инициализирующая репозиторий в заданной директории;

* *git status* - команда, отображающая информацию о текущем состоянии репозитория;

* *git add* - команда добавляет содержимое рабочего каталога в индекс для последующего сохранения;

* *git commit* - команда фиксирует добавленные в индекс изменения;

* *git log* - команда позволяет найти конкретную версию проекта или определить изменения, которые будут внесены при выполнении слияния в функциональной ветке;

* *git checkout* - позволяет переключаться между версиями;

* *git diff* - команда показывает разницу между текущим файлом и сохраненным.

## Синтаксис языка Markdown

* **жирный текст** - **
* *курсивный текст* - *
* ~~зачеркнутый текст~~ - ~~
* выделение заголовка - # (в начале строки);
* выделить уровень заголовка - = или **** (в начале строки);
* нумерованные списки - 1, 2, 3... (в начале строки);
* ненумерованные списки - * (в начале строки);
* вложенные списки - выполняем отсупы (в начале строки).

## Работа с ветками
_**Ветвление**_ (branching) означает отклонение от основной линии разработки, после которого работа перестает затрагивать эту самую основную линию.

### 1. Создание веток
* **_git branch branch_name_** - команда для создания ветки;

* **_git checkout branch_name_** - команда переключение с одной ветки на другую;

* **_git branch_** - команда для проверки в какой ветке мы находимся;

* **_git log_** - команда покажет состояние более новых версий проекта, но при вызове из самой "свежей" ветке, мы не увидим исходного файла.

### 2. Слияние веток

* **_git merge branch_name_** - команда, осуществляющая слияние между текущей веткой и branch_name.

### 3. Конфликты при слиянии

При слиянии веток, по-разному фиксирующих изменения одних и тех же областей проекта, возникает конфликт слияния.

#### **Типы конфликтов**:
* Git прерывает работу в самом начале слияния, если обнаруживает изменения в рабочем каталоге или разделе проиндексированных файлов текущего проекта. Git не может выполнить слияние, поскольку иначе эти ожидающие изменения будут перезаписаны новыми коммитами.
* Git прерывает работу во время слияния, если в наличии конфликт между текущей локальной веткой и веткой, с которой выполняется слияние.


#### **Команды для разрешения конфликтов**
* **git status** - команда, позволяющая идентифицировать конфликтующие во время слияния файлы;
* **git log --merge** - команда, создающая журнал со списком конфликтов коммитов между ветками, для которых выполняется слияние;
* **git diff** - команда помогает найти различия между состояниями репозитория/файлов;
* **git merge --abort** - команда, прерывающая процесс слияния будет прерван, а ветка вернется к состоянию, в котором она находилась до начала слияния;
* **git reset** - команда, восстанавливающая заведомо удовлетворительное состояние конфликтующих файлов.

## Работа с изображением
В Git не принято добавлять файлы изображений, их хранят на сторонних носителях. Для исключения ненужных файлов из загрузки, их добавляют в **_.gitignor_**.
+ для добавления изображение в текст, достаточно написать следующее:
![А ты правильно замотивировал коллег?](antimotivator.jpg)

## Работа с удаленным репозиторием

**_Удаленный репозиторий_** ("внешний") – это версии вашего проекта, сохраненные на удаленном сервере. Доступ к репозиторию на таком сервере может осуществляться по интернету или по локальной сети.

У удаленного репозитория есть собственные ветки, собственный указатель HEAD, своя история коммитов и т.д. Если мы подключим удаленный репозиторий к своему локальному, то у нас появятся копии всех ссылочных объектов удаленного репозитория.

**Принято** называть **удаленные ветки** (то есть ветки удаленных репозиториев), **приписывая** к их названию **имя удаленного репозитория**. Например, если у нас есть удаленный репозиторий с именем *origin* и веткой *main*, то мы будем называть такую ветку _origin/main_.

### Команды

* **_git remote add <название удаленного репозитория> <ссылка на удаленный репозиторий>_** - команда подключает удаленный репозиторий к вашему под переданным именем;

* **_git remote remove <название удаленного репозитория>_** - команда отключает переданный удаленный репозиторий от вашего;

* **_git remote rename <старое имя удаленного репозитория> <новое имя удаленного репозитория>_** - команда меняет имя переданного удаленного репозитория;

* **_git remote show [имя удаленного репозитория]_** - команда выводит список всех подключенных удаленных репозиториев. Если передано имя репозитория, то выводит информацию об этом репозитории;

* **_git clone <ссылка на удаленный репозиторий>_** - команда клонирует переданный репозиторий на ваш компьютер;

* **_git fetch_** - команда используется для синхронизации локальных ссылочных объектов с этими же объектами в удаленном репозитории. Рабочую копию она не меняет;

* **_git pull_** - команда получает изменения из переданного удаленного репозитория и обновляет рабочую копию в соответствии с удаленным репозиторием;

* **_git push_** - команда загружает изменения в удаленный репозиторий.

### Настройка совместной работы

Необходимость подключить удаленный репозиторий к уже существующему локальному возникает в ситуациях, когда вы решаете выгрузить уже написанный код на удаленный сервер. Это нужно, чтобы другие разработчики смогли получить к нему доступ или чтобы вы сами могли заниматься разработкой с нескольких компьютеров (например, домашнего и рабочего).

1. Создать аккаунт на [GitHub.com](https://github.com/)
2. Создать локальный репозиторий 
3. "Связать" локальный и удаленный репозиторий
4. Отправить (push) локальный репозиторий в удаленный
5. Провести изменения "с другого компьютера"
6. "Выкачать" (pull) актуальное состояние из удаленного репозитория.

### Пулл-реквест

**_Пулл-реквест_** (от англ. pull-request – запрос pull) – функция GitHub, позволяющая попросить владельца репозитория, от которого мы сделали форк, загрузить наши изменения обратно в свой репозиторий/

1. Сделать ответвление (fork) репозитория
2. Сделать git clone *своей* версии репозитория
3. Создать новую ветку и в *неё* вносим изменеия
4. Фиксировать изменения (коммиты)
5. Отправить свою версию в *свой* GitHub
6. На сайте GitHub нажать кнопку pull request.

